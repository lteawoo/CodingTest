# 체육복 - 탐욕법
https://programmers.co.kr/learn/courses/30/lessons/42862

## 풀이
탐욕법의 특징은 부분해가 전체해가 되는 것, 다시 말해서 매 순간 최적의 선택을 하다보면 답이나온다.

N은 학생 수, L은 잃어버린 학생, R은 2벌 갖고있는 학생
* N: 2, L: [1], R: [2] 일때는 2명 전부 입을 수 있음 -> 1번 학생이 2번한테 빌림
* N: 5, L: [3], R: [1, 4] 일때는 5명 전부 입을 수 있음 -> 3번 학생이 4번한테 빌림
* N: 2, L: [1], R: [3] 일때는 1명만 입을 수 있음 -> 인접한 학생만 빌려주므로 못 빌려줌

탐욕법 답게 풀이하자면 **갖고 있거나 앞뒤로 빌릴 수 있는 학생**만 카운트, 결과적으로 입을 수 있는 학생수가 나온다.


## 처리 순서
1. 메모라이징
    * 학생 마다 체육복을 갖고있냐 안 갖고있냐의 상태값을 가질 수 있음(1: 2벌, 0: 1벌, -1: 0벌)
    * 처음엔 HashMap으로 했다가 복잡하여 정수 배열로 변환함
    * 중요: int배열의 요소들은 0으로 초기화된다.(단순화에 좋음)
```java
    int[] pFlags = new int[n];

    for (int i = 0; i < lost.length; i++) {
        pFlags[lost[i] - 1]--;
    }
    for (int i = 0; i < reserve.length; i++) {
        pFlags[reserve[i] - 1]++;
    }
```
학생 수 만큼의 배열을 만들고, 잃었으면 -1, 2벌이면 1, 1벌이면 0으로 계산

2. 갖고있는 학생, 잃어버렸지만 앞뒤로 빌린 학생 카운트
```java
    for (int i = 0; i < n; i++) {
        if (pFlags[i] >= 0) { // 갖고있는 학생
            answer++;
        } else { // 잃어버린 학생 중에
            if (i > 0 && pFlags[i - 1] > 0) { // 앞에서 빌림
                pFlags[i - 1]--;
                answer++;
            } else if (i < n-1 && pFlags[i + 1] > 0) { // 뒤에서 빌림
                pFlags[i + 1]--;
                answer++;
            }
        }
    }
```